#!/bin/sh

main() {
  #@ Define metadata
  _cmd_PATH="$(search_all "$0")"
  _cmd_NAME="$(basename "$_cmd_PATH")"
  _cmd_HOME="$(dirname -- "$_cmd_PATH")"
  _cmd_AUTHOR="Craole"
  _cmd_USAGE="$_cmd_NAME [OPTIONS] <target_path>"
  _cmd_VERSION="1.5.0"
  _cmd_DESCRIPTION="Search for a target in the filesystem and in the PATH"
  _cmd_DEPENDENCIES="coreutils, fd, find"

  #@ Parse arguments
  parse_arguments "$@"
  execute_process
}

parse_arguments() {
  unset path pathlist

  while [ "$#" -ge 1 ]; do
    case "$1" in
    --cwd) cwd="$2" ;;
    --include-hidden | --hidden) hidden=true ;;
    --limit) limit="$2" ;;
    --closest)
      sort="closest"
      limit=1
      depth="any"
      direction="both"
      ;;
    --first)
      sort="alnum"
      limit=1
      depth="any"
      direction="both"
      ;;
    *) pattern="$1" ;;
    esac
    shift
  done

  pattern="$(prep_lookup "$pattern")"
  [ "$pattern" ] && {
    hidden="${hidden:-true}"
  }

  [ "$cwd" ] || cwd="$(pwd -P)"
  [ "$sort" ] || sort="natural" # depth, alphanumeric, natural, unsorted

  case "$limit" in ![0-9]*) limit="" ;; esac

  case $depth in
  [0-9]*) ;;
  any) unset depth ;;
  least | closest) depth=0 ;;
  one*) depth="1" ;;
  esac

  direction="both"
  # echo "PATTERN: $pattern"
  # echo "HIDDEN: $hidden"
  # echo "SORT: $sort"
  # echo "LIMIT: $limit"
  # echo "DEPTH: $depth"
  # echo "DIRECTION: $direction"

}

execute_process() {
  [ -e "$pattern" ] && {
    printf "%s" "$pattern"
    exit 0
  }

  result="$(search_all)"
  printf "%s" "$result"

  #@ Check if the target path is a known binary
  # if [ -e "$path" ]; then
  #   printf "%s" "$path"
  # elif [ "$path" ]; then
  #   # logline \
  #   #   --error "$_cmd_NAME" "The path to '$1' does not exist" \
  #   #   --fatal 2
  #   printf "ERROR: %s |> The path to '%s' does not exist" "$_cmd_NAME" "$1"
  #   printf "%s" "$_cmd_USAGE"
  #   return 2
  # else
  #   # logline \
  #   #   --error "$_cmd_NAME" "Unable to locate path to '$1'" \
  #   #   --fatal 1
  #   printf "ERROR: %s |> Unable to locate path to '%s'" "$_cmd_NAME" "$1"
  #   printf "%s" "$_cmd_USAGE"
  #   return 1
}

prep_lookup() {
  #doc Description
  #doc Parse arguments, resolve the given pattern to an absolute path if it is relative,
  #doc and return the resolved path. Otherwise, return the original pattern.
  #doc
  #doc Usage
  #doc prep_lookup [options] pattern
  #doc
  #doc Options
  #doc -c, --cwd cwd    The current working directory to resolve the pattern in.
  #doc
  #doc Examples
  #doc    prep_lookup -c /usr/share/icons foo.png
  #doc    $(pwd)/foo.png
  #doc
  #doc    prep_lookup ./usr/share/icons/foo.png
  #doc    /usr/share/icons/foo.png${reset}

  #@ Parse arguments
  while [ "$#" -ge 1 ]; do
    case $1 in
    -c | --cwd) cwd="$2" ;;
    *) pattern="$1" ;;
    esac
    shift
  done

  #@ Resolve the pattern to an absolute path if it is relative
  #@ Otherwise, return the original pattern
  case "$pattern" in
  ./*)
    #@ Remove the leading './' from the pattern if present
    pattern="${pattern#./}"

    #@ Return the prep_lookupd path
    printf "%s" "${cwd:-$(pwd)}/${pattern}"
    ;;
  *)
    #@ Return the original pattern
    printf "%s" "$pattern"
    ;;
  esac
}

search_exe() {
  #doc Check if a command exists in the system's PATH and return its path if found.
  #doc
  #doc Usage: search_exe <pattern>
  #doc
  #doc Description:
  #doc   This function searches for a command by name (pattern) in the system's PATH
  #doc   using the 'command -v' utility. If the command is found, the function returns
  #doc   the path to the executable. Otherwise, it returns nothing.

  command -v "$pattern" >/dev/null 2>&1 &&
    command -v "$pattern"
}

search_fs() {
  #doc Search the filesystem for a pattern in both directions from the
  #doc current working directory, and return the list of paths.
  #doc
  #doc Usage: search_fs [--cwd <directory>] <pattern>
  #doc
  #doc Options:
  #doc   --cwd: Set the current working directory to <directory>. If not provided,
  #doc          the current working directory is used.
  #doc
  #doc Examples:
  #doc   search_fs --cwd /home/user test.txt
  #doc   search_fs test.txt

  #@ Parse arguments
  while [ "$#" -ge 1 ]; do
    case "$1" in
    --cwd) cwd="$2" ;;
    --first | --closest) closest=true ;;
    *) pattern="$1" ;;
    esac
    shift
  done

  #@ Set defaults
  [ "$cwd" ] || cwd="$(pwd)"

  search_fs__downwards() {
    #doc Search for a pattern in the directory tree below the given directory,
    #doc recursively. The search is case-sensitive. The search is performed
    #doc downwards from the given directory, and the paths are returned as absolute
    #doc paths.
    #doc
    #doc Usage: search_fs__downwards <directory> <pattern>
    #doc
    #doc Options:
    #doc   <directory>: The directory to start the search from.
    #doc   <pattern>: The pattern to search for.
    #doc
    #doc Notes:
    #doc   The function returns nothing if the pattern is not found.

    dir="$1"
    target="$2"

    if type fd >/dev/null 2>&1; then
      cmd="fd --base-directory \"$dir\""
      opt="$opt --absolute-path --glob"
      [ "$hidden" ] && opt="$opt --hidden"
      # [ "$depth" ] && opt="$opt --max-depth $depth"
      pat="$target"
      # if [ "$pattern" ]; then
      #   fd --base-directory "$dir" --absolute-path --hidden --glob "$target"
      # else
      #   fd --base-directory "$dir" "$target"
      # fi
    elif type find >/dev/null 2>&1; then
      cmd="find \"$dir\""
      # opt="$opt -type f"
      pat="-wholename \"*/$target\""
    fi

    search_fs__result="$(eval "$cmd" "$opt" "$pat")"
    # echo ALL
    # echo "$search_fs__result"
    # [ "$depth" ]
    # [ "$limit" ] && path="$(
    #   printf "%s" "$search_fs__result" |
    #     sort -n |
    #     head -n "$limit"
    # )"
    search_fs__sort() {
      search_fs__result="
/home/craole/Documents/dotfiles/Configuration/cli/git/global/config
/home/craole/Documents/dotfiles/Configuration/cli/git10/config
/home/craole/Documents/dotfiles/.git/config
/home/craole/Documents/dotfiles/Configuration/cli/git100/config
/home/craole/Documents/dotfiles/Configuration/cli/git03/config
/home/craole/Documents/dotfiles/Configuration/cli/git11/config
/home/craole/Documents/dotfiles/configuration/cli/git2/config
/home/craole/Documents/dotfiles/Configuration/cli/git1/config
/home/craole/Documents/dotfiles/Configuration/cli/gitOne/config
/home/craole/Documents/dotfiles/Configuration/cli/Git1/config
/home/craole/Documents/dotfiles/Configuration/cli/git/backup/config
/home/craole/Documents/dotfiles/_hidden10/config
/home/craole/Documents/dotfiles/_hidden4/config
/home/craole/Documents/dotfiles/_hidden/config
/home/craole/Documents/dotfiles/1test/config
/home/craole/Documents/dotfiles/abc/config
/home/craole/Documents/dotfiles/123/config
/home/craole/Documents/dotfiles/abc_2/config
"

      sort_type="natural"
      sort_cmd="LC_ALL=C sort"
      sort_opt="--ignore-case"

      printf "SORT TYPE: %s\n" "$sort_type"

      starts_with_punctuation() {
        printf "%s" "$1" | while IFS= read -r line; do
          case "$line" in
          */[[:punct:]]*) printf "%s\n" "$line" ;;
          esac
        done
      }
      starts_without_punctuation() {
        printf "%s" "$1" | while IFS= read -r line; do
          case "$line" in
          */[[:punct:]]*) ;;
          *) printf "%s\n" "$line" ;;
          esac
        done
      }

      prune_list() {
        #@ Print the sorted list, removing any empty lines.
        printf "%s" "$1" | grep --invert-match '^$'
      }

      case "$sort_type" in
      depth | d*)
        sort_opt="$sort_opt --sort=human-numeric"
        printf "%s" "$search_fs__result" |
          awk -F'/' '{print NF-1, $0}' |
          eval "$sort_cmd $sort_opt" |
          cut -d' ' -f2-
        ;;
      lexical | l* | alphanumeric | alnum | a*)
        sort_opt="$sort_opt --sort=human-numeric"
        prune_list "$(
          starts_with_punctuation "$search_fs__result" | eval "$sort_cmd $sort_opt"
          starts_without_punctuation "$search_fs__result" | eval "$sort_cmd $sort_opt"
        )"
        ;;
      natural | n*)
        sort_opt="$sort_opt --sort=version"
        prune_list "$(
          starts_with_punctuation "$search_fs__result" |
            # Create a temporary lowercase list for sorting only
            tr '[:upper:]' '[:lower:]' |
            eval "$sort_cmd $sort_opt"
          starts_without_punctuation "$search_fs__result" |
            # Create a temporary lowercase list for sorting only
            tr '[:upper:]' '[:lower:]' |
            eval "$sort_cmd $sort_opt"
        )"
        ;;
      *)
        printf "%s" "$search_fs__result"
        ;;
      esac
    }

    search_fs__sort
  }

  search_fs__upwards() {
    #doc Search for the pattern in the current working directory and upwards.
    #doc
    #doc Usage: search_fs__upwards
    #doc
    #doc Description:
    #doc   This function searches for the given pattern in the current working directory
    #doc   and upwards. It runs search_fs__downwards in a loop until it reaches the root
    #doc   directory, at which point it stops.

    dir="$1"
    target="$2"

    while [ "$dir" != "/" ]; do
      result="$(search_fs__downwards "$dir" "$target")"
      [ "$result" ] && printf "%s" "$result" && break
      dir="$(dirname "$dir")"
    done
  }

  search_fs__closest() {
    #doc   Return the closest match to the current directory.
    #doc
    #doc   This function takes a list of paths and returns the closest one to the current directory.
    #doc   The algorithm works as follows:
    #doc
    #doc   1. Print each file path with its level of nesting (NF-1)
    #doc   2. Sort the file list by nesting level
    #doc   3. Remove the nesting level from each line
    #doc   4. Select the first item (i.e. the file closest to the current directory)
    #doc
    #doc   The closest file is defined as the file with the lowest nesting level. If two files have
    #doc   the same nesting level, the first one is returned.

    #@ Extract the desired path from the list
    path="$(
      printf "%s" "$pathlist" |
        awk -F'/' '{print NF-1, $0}' | # 1
        sort -n |                      # 2
        cut -d' ' -f2- |               # 3
        head -n 1                      # 4
    )"

    #@ Remove trailing backslash on Windows
    path="${path%\\}"

    #@ Remove trailing slash, if any
    path="${path%/}"

    #@ Return the path
    printf "%s" "$path"
  }

  #@ Search the filesystem in both directions
  pathlist="$(search_fs__downwards "$cwd" "$pattern")"
  [ "$pathlist" ] ||
    pathlist="$(search_fs__upwards "$cwd" "$pattern")"

  if [ "$closest" ]; then
    path="$(search_fs__closest "$pathlist")"
  else
    path="$pathlist"
  fi
  #@ Return the list of paths
  printf "%s" "$pathlist"
}

search_all() {
  #doc Search for a pattern in the current directory, the filesystem, and in the PATH.
  #doc
  #doc Usage: search_all [--cwd <directory>] [--first | --closest] <pattern>
  #doc
  #doc Options:
  #doc   --cwd: Set the current working directory to <directory>. If not provided,
  #doc          the current working directory is used.
  #doc   --first | --closest: Return the first match or the closest match to the
  #doc                    current directory.
  #doc
  #doc Examples:
  #doc   search_all --cwd /home/user --first test.txt
  #doc   search_all --cwd /home/user --closest test.txt

  #@ Parse arguments
  while [ "$#" -ge 1 ]; do
    case "$1" in
    --cwd) cwd="$2" ;;
    *) pattern="$1" ;;
    esac
    shift
  done

  #@ Define the pattern as the initial path return
  result="$pattern"

  #@ Check for the path among the known executables
  [ -e "$result" ] || result="$(search_exe "$pattern")"

  #@ Check for the path in the filesystem
  [ -e "$result" ] || result="$(search_fs --cwd "$cwd" "$pattern")"

  #@ Return the path or an empty string
  printf "%s" "$result"
}

tests() {
  main ls
  echo
  main bat
  echo
  main geet
  echo
  main adcocjohghhfpidemphmcmlmhnfgikei
}

main "$@"
# tests
