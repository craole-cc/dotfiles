#!/bin/sh
scr_name="$(basename "$0")"
scr_guide="$(
  cat <<EOF
Usage:
  $(basename "$0") <MODES> [COMMAND/OPTION] -- <ARGUMENTS>

Modes:
  -h, --help                  Display this help message
  -W, --watch                 Enable watch mode
  -L, --lib                   Enable lib mode
  -Q, --quiet                 Enable quiet mode
  -R, --release               Enable release mode
  -A, --all-features          Enable all-features mode

Build Options:
  -b                          Build all targets (default)
  -bb <BIN_NAME>              Build a specific binary
  -bt <TEST_NAME>             Run a specific test
  -be <EXAMPLE_NAME>          Build a specific example
  -bw <WORKSPACE_DIR>         Build within a workspace
  -bx <EXCLUDE_TARGETS>       Exclude specified targets

Run Options:
  -r                          Run the application
  -rb <BIN_NAME>              Run a specific binary
  -re <EXAMPLE_NAME>          Run a specific example
  -rp <PACKAGE_NAME>          Specify a package to run
  -ro <PROFILE_NAME>          Set the profile for the build
  -rt <TARGET_NAME>           Specify a target triple
  -rd <TARGET_DIR>            Specify the target directory
  -rj <NUM_JOBS>              Set the number of jobs for parallel builds

Test Options:
  -t                          Run tests with default options
  -tt <TEST_NAME>             Run a specific test (default: current directory name)

Package Commands:
  -a <PACKAGE>                Add packages to the project
  -x <PACKAGE>                Remove packages from the project
  -i <PACKAGE>                Install packages to the system
  -u <PACKAGE>                Uninstall packages from the system

EOF
)"

display_usage() {
  if [ "$#" -eq 0 ]; then
    #@ No arguments
    exit_code=0
  else
    if [ "$1" -eq "$1" ] 2>/dev/null; then
      #@ The first argument is a number
      exit_code="$1"
      shift
    else
      #@ The first argument is not a number
      exit_code=1
    fi
  fi
  #@ Display the error or custom message
  [ "$*" ] &&
    if [ "$exit_code" -ne 0 ]; then
      printf "Error: %s\n\n" "$*"
    else
      printf "%s\n\n" "$*"
    fi

  #@ Display the usage guide
  printf "%s\n" "$scr_guide"

  #@ Terminate
  exit "${exit_code:-0}"
}

cargo_cmd() {
  #@ Check if cargo is installed
  cargo --help >/dev/null 2>&1 || {
    printf "%s\n%s" \
      "Please ensure 'cargo' is installed and in your PATH." \
      "See https://www.rust-lang.org/tools/install for more information."
    exit 1
  }

  if [ "$2" ]; then
    printf "cargo watch --quiet --clear --exec \"%s\"" "$1"
  else
    printf "cargo %s" "$1"
  fi
}

get_option() {
  while [ $# -gt 0 ]; do
    case $1 in
    -p* | --p*)
      [ "$2" ] &&
        if [ "$2" -eq "$2" ] 2>/dev/null; then
          position="$2"
          shift
        else
          printf "Error: Position not a number\n"
          printf "Invalid position: %s\n" "$2"
          exit 66 #? Developer Error - Script Logic Error
        fi

      ;;
    -o* | --o*)
      [ "$2" ] && {
        options="$2"
        shift
      }
      ;;
    *)
      options="${options:-$1}"
      position="${position:-$2}"
      ;;
    esac
    shift
  done

  #@ Update position
  case "$options" in --*) offset=2 ;; -*) offset=1 ;; esac
  position="$(("${position:-1}" + offset))"

  #@ Debug
  # echo "Options: ${#options} [$options] | Position: $position | Offset: $offset"

  #@ Return the option
  if [ "$position" -gt "${#options}" ]; then
    printf "Error: Position out of range\n"
    printf "Invalid Position: %s | Max Position: %s | Actual Option: %s\n" \
      "$position" "${#options}" "$options"
    exit 66 #? Developer Error - Script Logic Error
  else
    printf "%s\n" "$options" | cut -c "$position"
  fi

}

parse_arguments() {

  internal() {
    [ $# -eq 0 ] && display_usage 1 "Missing arguments"

    case "$1" in -h | --help) display_usage ;; esac

    for argument in "$@"; do
      #@ Modes
      case "$argument" in --debug)
        debug=true
        verbose=true
        ;;
      esac
      case "$argument" in -D)
        verbose=true
        verbosity="--verbose"
        ;;
      esac
      case "$argument" in -Q) verbosity="--quiet" ;; esac
      case "$argument" in -W) watch=true ;; esac
    done
  } && internal "$@"

  external() {
    while [ $# -gt 0 ]; do
      case "$1" in
      -a*)
        #> Command
        cmd="add"

        #> Option
        case "$(get_option "$1")" in
        h)
          opt="--help"
          ;;
        esac

        #> Argument
        unset arg
        ;;
      -b*)
        cmd="build"

        case "$(get_option --opt "$1" --pos 2)" in
        h)
          opt="--help"
          ;;
        b)
          if [ "$2" ]; then
            opt="--bin"
          else
            opt="--bins"
          fi
          ;;
        e)
          if [ "$2" ]; then
            opt="--example"
          else
            opt="--examples"
          fi
          ;;
        l)
          opt="--lib"
          ;;
        n)
          if [ "$2" ]; then
            opt="--bench"
          else
            opt="--benches"
          fi
          ;;
        t)
          if [ "$2" ]; then
            opt="--test"
          else
            opt="--test $(basename "$PWD")"
          fi
          ;;
        a)
          opt="--all-targets --all-features"
          ;;
        w)
          opt="--workspace"
          ;;
        x)
          opt="--exclude"
          ;;
        esac

        while [ $# -gt 1 ]; do
          case "$2" in --) break ;; -*) ;; *) opt="$opt $2" ;; esac
          shift
        done
        ;;
      -c*)
        #@ Command
        cmd="clean"

        #@ Options
        case "$(get_option "$1")" in
        h) opt="--help" ;;
        p)
          shift
          opt="$opt $*"
          ;;
        esac

        #@ Arguments
        unset arg
        ;;
      -r*)
        cmd="run"

        case "$(get_option --opt "$1" --pos 2)" in
        h) opt="--help" ;;
        b) opt="--bin" ;;
        e) opt="--example" ;;
        j) opt="--jobs" ;;
        p) opt="--package" ;;
        o) opt="--profile" ;;
        t) opt="--target" ;;
        d) opt="--target-dir" ;;
        r | a) opt="--all-features --release" ;;
        u | g) opt="--unit-graph" ;;
        esac

        while [ $# -gt 1 ]; do
          case "$2" in -*) ;; *) opt="$opt $2" ;; esac
          shift
        done
        ;;
      -t*)
        cmd="test"

        case "$(get_option --opt "$1" --pos 2)" in
        h)
          opt="--help"
          ;;
        b)
          if [ "$2" ]; then
            opt="--bin"
          else
            opt="--bins"
          fi
          ;;
        e)
          if [ "$2" ]; then
            opt="--example"
          else
            opt="--examples"
          fi
          ;;
        l)
          opt="--lib"
          ;;
        n)
          if [ "$2" ]; then
            opt="--bench"
          else
            opt="--benches"
          fi
          ;;
        t)
          if [ "$2" ]; then
            opt="--test"
          else
            opt="--test $(basename "$PWD")"
          fi
          ;;
        a)
          opt="--all-targets --all-features"
          ;;
        w)
          opt="--workspace"
          ;;
        x)
          opt="--exclude"
          ;;
        esac

        while [ $# -gt 1 ]; do
          case "$2" in --) break ;; -*) ;; *) opt="$opt $2" ;; esac
          shift
        done

        [ "$3" ] && shift

        arg="--nocapture --exact"
        while [ $# -gt 1 ]; do
          case "$2" in --) break ;; -*) ;; *) arg="$arg $2" ;; esac
          shift
        done
        ;;
      *)
        case $1 in
        -Q | -D | -W | --debug) ;;
        *) cmd="$cmd $1" ;;
        esac
        ;;
      esac
      shift
    done
  } && external "$@"
}

process() {
  #@ Join the command parts
  [ "$opt" ] || opt="$verbosity $opt"
  [ "$arg" ] && arg=" -- $arg"
  cmd="$cmd $opt $arg"

  #@ Ensure watch is used only on test and run commands
  case "$cmd" in "test "* | "run "*) ;; *) unset watch ;; esac

  #@ Update the command according to the mode
  cmd="$(cargo_cmd "$cmd" "$watch")"

  #@ Display the command
  [ "$verbose" ] && printf "/> %s\n" "$cmd"

  #@ Execute the command
  [ "$debug" ] || eval "$cmd"
}

main() {
  parse_arguments "$@"
  process
} && main "$@"
