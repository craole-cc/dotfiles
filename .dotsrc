#!/bin/sh

establish_utilities() {
  set_verbosity_level() {
    #@ Check for global verbosity settings
    # shellcheck disable=SC2153
    case "$verbose$verbosity$VERBOSE$VERBOSITY" in
    [1-9]) VERBOSITY="$verbose$verbosity$VERBOSE$VERBOSITY" ;;
    true) VERBOSITY=1 ;;
    false | 0 | '') VERBOSITY=0 ;;
    esac

    #@ Check for local verbosity override
    [ -n "$1" ] &&
      case "$1" in
      [1-9]) VERBOSITY="$1" ;;
      true) VERBOSITY=1 ;;
      false | 0 | '') VERBOSITY=0 ;;
      *) printf "%s\n" "Unknown verbosity level: $1" ;;
      esac

    #@ Make variables available globally
    [ "$VERBOSITY" ] && export VERBOSITY
  }

  set_dots_path() {
    #@ Set the path to the DOTS directory based in argument
    case "$1" in --default) ;; *) DOTS="$1" ;; esac

    #@ Ensure the path is a directory or default to the current directory
    if [ -d "$DOTS" ]; then
      #@ Print the DOTS variable
      case "$VERBOSITY" in
      0) ;;
      *) printf "DOTS: %s\n" "$DOTS" ;;
      esac
    else
      #@ Find the path of the current script
      DOTS_RC="$0"

      #@ Use readlink to resolve symlinks
      while [ -L "$DOTS_RC" ]; do
        DOTS_RC="$(readlink "$DOTS_RC")"
      done

      #@ Set the DOTS variable as the parent directory
      DOTS="$(cd "$(dirname "$DOTS_RC")" >/dev/null 2>&1 && pwd)"

      #@ Print the DOTS variable
      case "$VERBOSITY" in
      0) ;;
      1) printf "DOTS: %s\n" "$DOTS" ;;
      *) printf "DOTS set relative to .dotrc: %s\n" "$DOTS" ;;
      esac
    fi

    export DOTS
  }

  set_dots_ignore() {

    #@ Set the DOTS_IGNORE variable
    case "$1" in --default) shift ;; esac
    DOTS_IGNORE="${1:-$DOTS/.ignore}"

    #@ Create the DOTS_IGNORE file, if necessary
    [ -f "$DOTS_IGNORE" ] || touch "$DOTS_IGNORE"
  }

  set_interactive_shell() {
    #@ Set the preferred interactive shell prompt
    SHELL_INTERACTIVE="${1:-bash}"

    #@ Ensure the variable is available globally
    export SHELL_INTERACTIVE
  }

  get_os_type() {
    if [ "$WSL_DISTRO_NAME" ]; then
      os_type="Windows Subsystem for Linux [WSL]"
    elif [ -f "/proc/version" ]; then
      os_type=$(cat "/proc/version")
    elif command -v uname >/dev/null 2>&1; then
      os_type="$(uname --kernel-name)"
    elif command -v python >/dev/null 2>&1; then
      os_type="$(
        python -c 'import platform; print(platform.system())'
      )"
    elif command -v hostnamectl >/dev/null 2>&1; then
      os_type="$(
        hostnamectl | awk -F ': ' '/Kernel/ {print $2}'
      )"
    fi

    case "$(printf "%s" "$os_type" | tr '[:upper:]' '[:lower:]')" in
    *linux* | *gnu*) os_type="GNU/Linux" ;;
    *wsl* | *microsoft*) os_type="Windows Subsystem for Linux [WSL]" ;;
    *cygwin* | *msys* | *mingw* | *windows*) os_type="Windows" ;;
    *darwin*) os_type="Mac" ;;
    *freebsd*) os_type="FreeBSD" ;;
    *netbsd*) os_type="NetBSD" ;;
    *openbsd*) os_type="OpenBSD" ;;
    *hp*) os_type="HP" ;;
    *solaris* | *sunos*) os_type="Solaris" ;;
    *aix*) os_type="AIX" ;;
    *irix*) os_type="IRIX" ;;
    esac
  }

  update_user_profile() {
    #@ Update the user's DOTS variable
    # [ -f "$DOTS/Bin/tasks/dots.init" ] &&
    #   . "$DOTS/Bin/tasks/dots.init"

    # Escape the special characters in the variable for safe use in sed
    escaped_dots=$(printf "%s" "$DOTS" | sed 's/[\/&]/\\&/g')

    # Check if the DOTS variable already exists in ~/.profile
    if grep -q "^DOTS=\"$escaped_dots\"$" "$HOME/.profile"; then
      [ "$verbose" ] && printf "DOTS variable in ~/.profile is already up to date.\n"
    else
      # Add or update the DOTS variable in ~/.profile
      if grep -q "^DOTS=" "$HOME/.profile"; then
        # DOTS variable exists, update it
        sed -i "s/^DOTS=.*/DOTS=\"$escaped_dots\"/" "$HOME/.profile"
        [ "$verbose" ] && printf "Updated DOTS variable in ~/.profile.\n"
      else
        # DOTS variable doesn't exist, add it to ~/.profile
        echo "DOTS=\"$escaped_dots\"" >>"$HOME/.profile"
        [ "$verbose" ] && printf "Added DOTS variable to ~/.profile.\n"
      fi
    fi
  }

  set_local_flags() {
    get_os_type
    [ "$os_type" = "Windows" ] && windows_flag=true
    [ "$VERBOSITY" -gt 0 ] && verbose_flag=true
    [ "$DOTS_IGNORE" ] && ignore_file="$DOTS_IGNORE"
  }

  print_usage_guide() {
    printf "%s\n" "$usage_guide"
    exit "$exit_code"
  }

  get_sources() {
    prep_ignore() { #? Update .ignore file
      if [ "$ignore_action" = "EXCLUDE" ]; then
        grep --line-regexp --quiet "$1" "$ignore_file" ||
          printf "\n%s" "$1" >>"$ignore_file"
      elif [ "$ignore_action" = "INCLUDE" ]; then
        sed --in-place "/$1/d" "$ignore_file"
      else
        return 0
      fi
    }

    src_exclude() {
      #? Remove blank lines
      sed -i '/^[[:space:]]*$/d' "$ignore_file"

      #? Sort alphabetically
      sort --human-numeric-sort --output "$ignore_file" "$ignore_file"

      #? Prep for use with `grep`
      # sed -e 's/^/\//g' -e 's/$/*/g' "$ignore_file" |
      sed -e 's/^/\//g' "$ignore_file" |
        tr '\n' '|' | sed '$s/|$/\n/'
    }

    src_include() {
      if [ "$(src_exclude)" ]; then
        grep \
          --extended-regexp \
          --invert-match \
          --ignore-case \
          "$(src_exclude)" |
          sort
      else
        sort
      fi
    }

    #? Identify valid sources
    generate_sources() {
      find "$1" | src_include
    }

    if [ ! -e "$1" ]; then
      prep_ignore "$1"
    else
      generate_sources "$1"
    fi
  }

  process_sources() {
    #| Enable global variable export
    set -o allexport

    #| Process sources recursively
    for src_path in $(get_sources "$1"); do
      [ -d "$src_path" ] && [ "$src_type" = "XDG" ] &&
        case ":${XDG_DATA_DIRS}:" in
        *:"$src_path":*) ;;
        *)
          XDG_DATA_DIRS="${src_path}${XDG_DATA_DIRS:+:${XDG_DATA_DIRS}}"
          [ "$verbose_flag" = true ] && printf "Appended to XDG_DATA_DIRS: %s\n" "${src_path}"
          ;;
        esac

      #| Update PATH directories
      [ -d "$src_path" ] && [ "$src_type" = "BIN" ] &&
        case ":${PATH}:" in
        *:"$src_path":*) ;;
        *)
          PATH="${PATH:+$PATH:}$src_path"
          [ "$verbose_flag" = true ] && printf "Appended to PATH: %s\n" "${src_path}"
          ;;
        esac

      #| Activate Scripts and Variables
      [ -f "$src_path" ] &&

        #| Make scripts executable
        if [ "$src_type" = "BIN" ]; then
          if [ "$verbose_flag" = true ]; then
            [ "$windows_flag" = true ] || chmod --changes +x "$src_path"
          else
            [ "$windows_flag" = true ] || chmod +x "$src_path"
          fi

        #| Load environmental variables from files
        elif [ "$src_type" = "ENV" ]; then
          # shellcheck disable=SC1090
          # EOLor --lf "$src_path"
          . "$src_path"
          [ "$verbose_flag" = true ] && printf "Initialized: %s\n" "$src_path"
        fi

    done

    #| Disable global export
    set +o allexport
  }

  initialize_source() {
    #| Core Arguments
    case "$1" in
    -h | --help)
      exit_code=0
      print_usage_guide
      ;;
    -v | --version)
      printf "%s\n" "$version"
      exit 0
      ;;
    -d | --verbose)
      verbose_flag=true
      shift
      ;;
    -t | --simulate | --test)
      test_flag=true
      shift
      ;;
    -q | --quiet)
      unset verbose_flag
      shift
      ;;
    --ignore-file)
      ignore_file="$2"
      shift 2
      ;;
    *) ;;
    esac

    #| Process Arguments
    while [ "$#" -ge 1 ]; do
      case "$1" in
      --bin) #| Expects a file/directory
        src_type="BIN"
        shift
        ;;
      --env) #| Expects a file/directory
        src_type="ENV"
        shift
        ;;
      --xdg) #| Expects a directory
        src_type="XDG"
        shift
        ;;
      --exclude) #| Expects a string
        ignore_action="EXCLUDE"
        shift
        ;;
      -I | --include) #| Expects a string
        ignore_action="INCLUDE"
        shift
        ;;
      -*)
        printf "Invalid Option: %s\n" "$1"
        exit_code=1
        print_usage_guide
        ;;
      *) ;;
      esac

      if [ "$test_flag" = true ]; then
        # echo "Testing"
        simulate_initialization "$1"
      else
        # echo "Processing"
        process_sources "$1"
      fi

      shift
    done
  }

  simulate_initialization() {
    # [ "$src_type" ] && printf "\n%s: %s\n" "$src_type" "$1"
    # [ "$ignore_action" ] && printf "%s: %s\n" "$ignore_action" "$1"
    get_sources "$1"
  }

  cleanup() {
    [ "$reset_flag" = true ] &&
      rm -rf "$ignore_file"

    unset -v \
      BIN_ \
      ENV_ \
      src_path \
      src_type \
      ignore_file \
      reset_flag \
      test_flag \
      verbose_flag
  }
}

establish_environment() {
  #@ Set the verbosity level
  set_verbosity_level 1

  #@ Set the interactive shell
  set_interactive_shell bash

  #@ Ensure DOTS variable is set if not use the path of the current file
  set_dots_path --default

  #@ Establish IGNORE path to declare directories to skip
  set_dots_ignore --default

  #@ Establish the script environment variables
  cleanup
  set_local_flags
}

execute() {
  #@ Load Environment
  initialize_source \
    --exclude "archive" "review" "template" "temp" "tmp" \
    --bin "$DOTS/Bin" \
    --env "$DOTS/Environment/export"

  #@ Load Shell
  shell.init bash

  #@ Load Fonts
  fonts.init

  #@ Update the user profile
  update_user_profile
}

main() {
  establish_utilities
  establish_environment
  execute
} && main "$@"
