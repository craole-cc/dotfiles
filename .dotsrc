#!/bin/sh

establish_utilities() {
  set_verbosity_level() {
    #@ Check for global verbosity settings
    # shellcheck disable=SC2153
    case "$verbose$verbosity$VERBOSE$VERBOSITY" in
    [1-9]) VERBOSITY="$verbose$verbosity$VERBOSE$VERBOSITY" ;;
    true) VERBOSITY=1 ;;
    false | 0 | '') VERBOSITY=0 ;;
    esac

    #@ Check for local verbosity override
    [ -n "$1" ] &&
      case "$1" in
      [1-9]) VERBOSITY="$1" ;;
      true) VERBOSITY=1 ;;
      false | 0 | '') VERBOSITY=0 ;;
      *) printf "%s\n" "Unknown verbosity level: $1" ;;
      esac

    #@ Make variables available globally
    [ -n "$VERBOSITY" ] && export VERBOSITY
  }

  set_dots_path() {
    #@ Set the path to the DOTS directory based in argument
    case "$1" in --default) ;; *) DOTS="$1" ;; esac

    #@ Ensure the path is a directory or default to the current directory
    if [ -d "$DOTS" ]; then
      #@ Print the DOTS variable
      case "$VERBOSITY" in
      0) ;;
      *) printf "DOTS: %s\n" "$DOTS" ;;
      esac
    else
      #@ Find the path of the current script
      DOTS_RC="$0"

      #@ Use readlink to resolve symlinks
      while [ -L "$DOTS_RC" ]; do
        DOTS_RC="$(readlink "$DOTS_RC")"
      done

      #@ Set the DOTS variable as the parent directory
      DOTS="$(cd "$(dirname "$DOTS_RC")" >/dev/null 2>&1 && pwd)"

      #@ Print the DOTS variable
      case "$VERBOSITY" in
      0) ;;
      1) printf "DOTS: %s\n" "$DOTS" ;;
      *) printf "DOTS set relative to .dotrc: %s\n" "$DOTS" ;;
      esac
    fi

    export DOTS
  }

  set_dots_ignore() {

    #@ Set the DOTS_IGNORE variable
    case "$1" in --default) shift ;; esac
    DOTS_IGNORE="${1:-$DOTS/.ignore}"

    #@ Create the DOTS_IGNORE file, if necessary
    [ -f "$DOTS_IGNORE" ] || touch "$DOTS_IGNORE"
  }

  set_interactive_shell() {
    #@ Set the preferred interactive shell prompt
    SHELL_INTERACTIVE="${1:-bash}"

    #@ Ensure the variable is available globally
    export SHELL_INTERACTIVE
  }

  get_os_type() {
    if [ "$WSL_DISTRO_NAME" ]; then
      os_type="Windows Subsystem for Linux [WSL]"
    elif [ -f "/proc/version" ]; then
      os_type=$(cat "/proc/version")
    elif command -v uname >/dev/null 2>&1; then
      os_type="$(uname --kernel-name)"
    elif command -v python >/dev/null 2>&1; then
      os_type="$(
        python -c 'import platform; print(platform.system())'
      )"
    elif command -v hostnamectl >/dev/null 2>&1; then
      os_type="$(
        hostnamectl | awk -F ': ' '/Kernel/ {print $2}'
      )"
    fi

    case "$(printf "%s" "$os_type" | tr '[:upper:]' '[:lower:]')" in
    *linux* | *gnu*) os_type="GNU/Linux" ;;
    *wsl* | *microsoft*) os_type="Windows Subsystem for Linux [WSL]" ;;
    *cygwin* | *msys* | *mingw* | *windows*) os_type="Windows" ;;
    *darwin*) os_type="Mac" ;;
    *freebsd*) os_type="FreeBSD" ;;
    *netbsd*) os_type="NetBSD" ;;
    *openbsd*) os_type="OpenBSD" ;;
    *hp*) os_type="HP" ;;
    *solaris* | *sunos*) os_type="Solaris" ;;
    *aix*) os_type="AIX" ;;
    *irix*) os_type="IRIX" ;;
    esac
  }

  update_user_profile() {
    #@ Update the user's DOTS variable
    [ -f "$DOTS/Bin/tasks/dots.init" ] &&
      . "$DOTS/Bin/tasks/dots.init"
  }

  set_local_flags() {
    get_os_type
    [ "$os_type" = "Windows" ] && windows_flag=true
    [ "$VERBOSITY" -gt 0 ] && verbosity_flag=true
    [ "$DOTS_IGNORE" ] && ignore_file="$DOTS_IGNORE"
  }
}

establish_environment() {
  #@ Set the verbosity level
  set_verbosity_level 1

  #@ Set the interactive shell
  set_interactive_shell bash

  #@ Ensure DOTS variable is set if not use the path of the current file
  set_dots_path --default

  #@ Establish IGNORE path to declare directories to skip
  set_dots_ignore --default

  #@ Establish the script environment variables
  cleanup
  set_local_flags
}

execute() {
  #@ Load Environment
  initialize_source \
    --exclude "archive" "review" "template" "temp" "tmp" \
    --bin "$DOTS/Bin" \
    --env "$DOTS/Environment/export"

  #@ Load Shell
  shell.init bash

  #@ Load Fonts
  # fonts.init

  #@ Update the user profile
  # update_user_profile

  echo "$sys_INFO"
  echo "$sys_LABEL"
}

print_usage_guide() {
  printf "%s\n" "$usage_guide"
  exit "$exit_code"
}

get_sources() {

  prep_ignore() { #? Update .ignore file
    if [ "$ignore_action" = "EXCLUDE" ]; then
      grep --line-regexp --quiet "$1" "$ignore_file" ||
        printf "\n%s" "$1" >>"$ignore_file"
    elif [ "$ignore_action" = "INCLUDE" ]; then
      sed --in-place "/$1/d" "$ignore_file"
    else
      return 0
    fi
  }

  src_exclude() {
    #? Remove blank lines
    sed -i '/^[[:space:]]*$/d' "$ignore_file"

    #? Sort alphabetically
    sort --human-numeric-sort --output "$ignore_file" "$ignore_file"

    #? Prep for use with `grep`
    # sed -e 's/^/\//g' -e 's/$/*/g' "$ignore_file" |
    sed -e 's/^/\//g' "$ignore_file" |
      tr '\n' '|' | sed '$s/|$/\n/'
  }

  src_include() {
    if [ "$(src_exclude)" ]; then
      grep \
        --extended-regexp \
        --invert-match \
        --ignore-case \
        "$(src_exclude)" |
        sort
    else
      sort
    fi
  }

  #? Identify valid sources
  generate_sources() {
    find "$1" | src_include
  }

  if [ ! -e "$1" ]; then
    prep_ignore "$1"
  else
    generate_sources "$1"
  fi
}

process_sources() {

  #| Enable global variable export
  set -o allexport

  #| Process sources recursively
  for src_path in $(get_sources "$1"); do
    [ -d "$src_path" ] && [ "$src_type" = "XDG" ] &&
      case ":${XDG_DATA_DIRS}:" in
      *:"$src_path":*) ;;
      *)
        XDG_DATA_DIRS="${src_path}${XDG_DATA_DIRS:+:${XDG_DATA_DIRS}}"
        [ "$verbose_flag" = true ] && printf "Appended to XDG_DATA_DIRS: %s\n" "${src_path}"
        ;;
      esac

    #| Update PATH directories
    [ -d "$src_path" ] && [ "$src_type" = "BIN" ] &&
      case ":${PATH}:" in
      *:"$src_path":*) ;;
      *)
        PATH="${PATH:+$PATH:}$src_path"
        [ "$verbose_flag" = true ] && printf "Appended to PATH: %s\n" "${src_path}"
        ;;
      esac

    #| Activate Scripts and Variables
    [ -f "$src_path" ] &&

      #| Make scripts executable
      if [ "$src_type" = "BIN" ]; then
        if [ "$verbose_flag" = true ]; then
          [ "$windows_flag" = true ] || chmod --changes +x "$src_path"
        else
          [ "$windows_flag" = true ] || chmod +x "$src_path"
        fi

      #| Load environmental variables from files
      elif [ "$src_type" = "ENV" ]; then
        # shellcheck disable=SC1090
        # EOLor --lf "$src_path"
        . "$src_path"
        [ "$verbose_flag" = true ] && printf "Initialized: %s\n" "$src_path"
      fi

  done

  #| Disable global export
  set +o allexport
}

initialize_source() {
  #| Core Arguments
  case "$1" in
  -h | --help)
    exit_code=0
    print_usage_guide
    ;;
  -v | --version)
    printf "%s\n" "$version"
    exit 0
    ;;
  -d | --verbose)
    verbose_flag=true
    shift
    ;;
  -t | --simulate | --test)
    test_flag=true
    shift
    ;;
  -q | --quiet)
    unset verbose_flag
    shift
    ;;
  --ignore-file)
    ignore_file="$2"
    shift 2
    ;;
  *) ;;
  esac

  #| Process Arguments
  while [ "$#" -ge 1 ]; do
    case "$1" in
    --bin) #| Expects a file/directory
      src_type="BIN"
      shift
      ;;
    --env) #| Expects a file/directory
      src_type="ENV"
      shift
      ;;
    --xdg) #| Expects a directory
      src_type="XDG"
      shift
      ;;
    --exclude) #| Expects a string
      ignore_action="EXCLUDE"
      shift
      ;;
    -I | --include) #| Expects a string
      ignore_action="INCLUDE"
      shift
      ;;
    -*)
      printf "Invalid Option: %s\n" "$1"
      exit_code=1
      print_usage_guide
      ;;
    *) ;;
    esac

    if [ "$test_flag" = true ]; then
      # echo "Testing"
      simulate_initialization "$1"
    else
      # echo "Processing"
      process_sources "$1"
    fi

    shift
  done
}

simulate_initialization() {
  # [ "$src_type" ] && printf "\n%s: %s\n" "$src_type" "$1"
  # [ "$ignore_action" ] && printf "%s: %s\n" "$ignore_action" "$1"
  get_sources "$1"
}

cleanup() {
  [ "$reset_flag" = true ] &&
    rm -rf "$ignore_file"

  unset -v \
    BIN_ \
    ENV_ \
    src_path \
    src_type \
    ignore_file \
    reset_flag \
    test_flag \
    verbose_flag
}

main() {
  establish_utilities
  establish_environment
  execute
} && main "$@"
