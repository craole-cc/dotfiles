#!/bin/sh
# shellcheck disable=SC3028,SC2034

__readlink__() {
    : <<'DOCUMENTATION'
Execute the function in a *subshell* to localize variables and the effect of `cd`.

All commands below are invoked via `command`, so we must make sure that `command` itself is not redefined as an alias or shell function. This is done to mitigate it's inconsistency across shells.

`command` is a *builtin* in bash, dash, ksh, zsh, and some platforms do not even have an external utility version of it (e.g, Ubuntu). It bypasses aliases and shell functions and also finds builtins in bash, dash, and ksh. In zsh, option POSIX_BUILTINS must be turned on for that to happen.
DOCUMENTATION

    target="$1"
    fname=""
    targetDir=""
    CDPATH=""

    {
        \unalias command
        \unset -f command
    } >/dev/null 2>&1

    #? Allow zsh to find *builtins* with `command` too.
    # shellcheck disable=SC2034
    [ -n "$ZSH_VERSION" ] && options[POSIX_BUILTINS]=on

    #? Resolve potential symlinks until the ultimate target is found.
    while :; do
        [ -L "$target" ] || [ -e "$target" ] || {
            command printf '%s\n' "ERROR: '$target' does not exist." >&2
            return 1
        }
        #? Change to target dir; necessary for correct resolution of target path.
        command cd "$(command dirname -- "$target")" || return
        fname=$(command basename -- "$target") # Extract filename.
        [ "$fname" = '/' ] && fname=''         # !! curiously, `basename /` returns '/'
        if [ -L "$fname" ]; then
            # Extract [next] target path, which may be defined
            # *relative* to the symlink's own directory.
            # Note: We parse `ls -l` output to find the symlink target
            #       which is the only POSIX-compliant, albeit somewhat fragile, way.
            target=$(command ls -l "$fname")
            target=${target#* -> }
            continue # Resolve [next] symlink target.
        fi
        break # Ultimate target reached.
    done
    targetDir=$(command pwd -P) # Get canonical dir. path
    # Output the ultimate target's canonical path.
    # Note that we manually resolve paths ending in /. and /.. to make sure we have a normalized path.
    if [ "$fname" = '.' ]; then
        command printf '%s\n' "${targetDir%/}"
    elif [ "$fname" = '..' ]; then
        # Caveat: something like /var/.. will resolve to /private (assuming /var@ -> /private/var), i.e. the '..' is applied
        # AFTER canonicalization.
        command printf '%s\n' "$(command dirname -- "${targetDir}")"
    else
        command printf '%s\n' "${targetDir%/}/$fname"
    fi
}

# __run__() {
#     __PATH__=$(__readlink__ "$0")
#     __DIR__=$(dirname -- "$__PATH__")
#     __DIRx__="$(dirname "${BASH_SOURCE:-$0}")"
#     __NAME__=$(basename "$__PATH__")
#     __EXTN__=$(basename "${__PATH__##*.}")

#     cat <<INF
# *******************************************************
#         DIRECTORY: $__DIR__
#  DIRECTORY {BASH}: $__DIRx__
#          FILEPATH: $__PATH__
#          FILENAME: $__NAME__
#         EXTENSION: $__EXTN__
# *******************************************************
# INF
# }

# for path in "$@"; do
#     __run__ "$path"
# done
__readlink__ "$@"