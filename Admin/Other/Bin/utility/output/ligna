#!/bin/sh

init_scr_env() {
  scr_name="ligna"
  scr_version="0.1"
  scr_description="simple STDOUT horizontal line text alignment script."
  scr_usage="$(
    cat <<HELP
Usage: $scr_name [OPTIONS] [TEXT]
Description: $scr_name is a $scr_description

Options:
  -h, --help        Display this help message
  -v, --version     Display the version of $scr_name
  -d, --verbose     Enable verbose mode
  -c, --center      Align the text to the center (default)
  -r, --right       Align the text to the right
  -l, --left        Align the text to the left
  -p, --pad CHAR    Set the padding character
  --padl CHAR       Set the left padding character
  --padr CHAR       Set the right padding character
  --width WIDTH     Set the terminal width (default is auto-detect)

Arguments:
  TEXT              The text to be padded
  WIDTH             The number of characters for the terminal width
  CHAR              A single character to be repeated for padding

Note:
  - The options \`--pad\`, \`--padl\`, and \`--padr\` require an argument which must be a single character.
  - The \`--width\` option requires an argument which must be a positive integer representing the terminal width.
HELP
  )"

  unset verbose alignment pad_char pad_char_l pad_char_r text text_length buffer padding_length term_width padding_right padding_left padding
  term_width="${term_width:-$(get_len --term)}"
}

cleanup() {
  unset verbose alignment pad_char pad_char_l pad_char_r text text_length buffer padding_length term_width padding_right padding_left padding
} && trap cleanup EXIT

parse_arguments() {
  while [ $# -gt 0 ]; do
    case "$1" in
    -h | --help)
      print_help
      exit
      ;;
    -v | --version)
      print_version
      exit
      ;;
    -d | --verbose) verbose=true ;;
    -c | --center) alignment="center" ;;
    -r | --right) alignment="right" ;;
    -l | --left) alignment="left" ;;
    -p | --pad | --char)
      if [ "$2" ]; then
        pad_char="$2"
        shift
      else
        [ "$verbose" ] && printf "Error: Missing argument for %s\n" "$1"
      fi
      ;;
    --padl)
      if [ "$2" ]; then
        pad_char_l="$2"
        shift
      else
        [ "$verbose" ] && printf "Error: Missing argument for %s\n" "$1"
      fi
      ;;
    --padr)
      if [ "$2" ]; then
        pad_char_r="$2"
        shift
      else
        [ "$verbose" ] && printf "Error: Missing argument for %s\n" "$1"
      fi
      ;;
    --width)
      if [ "$2" ]; then
        term_width="$2"
        shift
      else
        [ "$verbose" ] && printf "Error: Missing argument for %s\n" "$1"
      fi
      ;;
    *) text="$1" ;;
    esac
    shift
  done
}

set_environment() {
  label="Terminal Width"
  term_width="${term_width:-$(get_len --term)}"
  is_number "$term_width" "$label"

  label="Text Length"
  text_length="$(get_len "$text")"
  is_number "$text_length" "$label"

  label="Buffer Length"
  if [ "$alignment" = "center" ]; then
    buffer_length=2
  else
    buffer_length=1
  fi

  label="Padding Character"
  default_char=" "
  pad_char_l="${pad_char_l:-${pad_char:-${pad_char_r:-$default_char}}}"
  pad_char_r="${pad_char_r:-${pad_char:-${pad_char_l:-$default_char}}}"

  [ "$pad_char_l" ] && validate_var "$pad_char_l" "Left $label"
  [ "$pad_char_r" ] && validate_var "$pad_char_r" "Right $label"

  label="Padding"
  [ "$term_width" -gt "$text_length" ] && padding_length=$(((term_width - text_length - buffer_length) / buffer_length))
  padding_left="$(repeat_char "$pad_char_l" "$padding_length")"
  padding_right="$(repeat_char "$pad_char_r" "$padding_length")"
}

repeat_char() {
  char="$1"
  reps="$2"
  printf "%-${reps}s" | tr " " "$char"
}

is_number() {
  var="$1"
  lbl="$2"

  case $var in
  '' | *[!0-9]*)
    #TODO use pout for error handling to replace printf and exit
    # printf "%s '%s', is not a valid number\n" "$lbl" "$var"
    [ "$verbose" ] &&
      embellish \
        --reset --underline --bg-red --fg-white \
        "$lbl Error:" \
        --reset --space --bold --red --italic \
        "$var" \
        --reset --space \
        "is not a valid number." \
        --reset --new-line
    exit 1
    ;;
  *) return 0 ;;
  esac
}

is_single_char() {
  var="$1"
  lbl="$2"

  if [ -z "$var" ]; then
    embellish \
      --reset --underline --bg-red --fg-white \
      "$lbl Error:" \
      --reset --space \
      "missing character" \
      --reset --new-line
    exit 1
  fi

  case $var in
  # Printable characters, including whitespace
  [[:print:]]) return 0 ;;
  *)
    #TODO use pout for error handling to replace printf and exit
    # printf "%s '%s', is not a valid single character\n" "$lbl" "$var"
    embellish \
      The \
      --reset --space --bold --red --italic \
      "$(printf "%s" "$lbl" | tr '[:upper:]' '[:lower:]')" \
      --reset --space --underline --bg-red --fg-white \
      ["$var"] \
      --reset --space \
      "is not a single character." \
      --reset --new-line

    exit 1
    ;;
  esac
}

validate_var() {
  var="$1"
  lbl="$2"
  scr="${3:-$scr_name}"

  if [ -z "$var" ]; then
    embellish \
      --reset --underline --bg-red --fg-white \
      "$lbl Error:" \
      --reset --space \
      "missing character" \
      --reset --new-line
    exit 1
  fi

  case $var in
  # Printable characters, including whitespace
  [[:print:]]) return 0 ;;
  *)
    #TODO use pout for error handling to replace printf and exit
    # printf "%s '%s', is not a valid single character\n" "$lbl" "$var"
    # --reset --space --underline --bg-red --fg-white \
    embellish \
      The \
      --reset --space --bold --red --italic \
      "$(printf "%s" "$lbl" | tr '[:upper:]' '[:lower:]')" \
      --reset --space --underline --doubleline \
      "$var" \
      --reset --space \
      "is invalid." \
      --reset --new-line \
      "For more information, run" \
      --reset --space --bold --italic \
      "$scr --help." \
      --reset --new-line

    exit 1
    ;;
  esac
}

get_len() {
  case $1 in
  --term) stty size 2>/dev/null | awk '{print $2}' ;;
  *) printf "%s" "${#1}" ;;
  esac
}

print_padded_text() {
  if [ "$padding_left" ] || [ "$padding_right" ]; then
    case "$alignment" in
    center)
      printf \
        "%s %s %s\n" \
        "${padding:-$padding_left}" \
        "$text" \
        "${padding:-$padding_right}"
      ;;
    right)
      printf "%s %s\n" "$padding_left" "$text"
      ;;
    left)
      printf "%s %s\n" "$text" "$padding_right"
      ;;
    esac
  else
    printf "%s\n" "$text"
  fi
}

print_help() {
  printf "%s\n" "$scr_usage"
}

print_version() {
  printf "%s\n" "$scr_version"
}

print_verbose_info() {
  [ "$verbose" ] || return
  cat <<EOF
         Alignment: $alignment
    Terminal Width: $term_width characters
       Text Length: $text_length character(s)
            Buffer: $buffer_length space(s)
EOF
  if [ "$padding" ]; then
    cat <<EOF
         Padding: $padding_length reps of '$pad_char'
EOF
  else
    cat <<EOF
           Padding: $padding_length reps of '$pad_char_r' and '$pad_char_l'
EOF
  fi
}

main() {
  init_scr_env
  parse_arguments "$@"
  set_environment
  print_verbose_info
  print_padded_text
}

main "$@"
